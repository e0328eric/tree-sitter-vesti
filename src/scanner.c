/*
 * This file was generated by Gemini because there is no time to write this
 * manually, although I could
 */

#include <tree_sitter/parser.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>

enum TokenType {
    LUACODE_PAYLOAD,
    LUACODE_END,
};

// Maximum length for the tag as per requirements (32) + buffer
#define MAX_TAG_LENGTH 32

typedef struct {
    char tag[MAX_TAG_LENGTH + 1];
    uint8_t tag_len;
} Scanner;

// --- Helper Functions ---

static inline void advance(TSLexer *lx) { lx->advance(lx, false); }
static inline void skip(TSLexer *lx)    { lx->advance(lx, true); }

// Custom alnum check to ensure ASCII only (as per requirements)
static inline bool is_ascii_alnum(int32_t c) {
    return (c >= 'a' && c <= 'z') || 
           (c >= 'A' && c <= 'Z') || 
           (c >= '0' && c <= '9');
}

// --- Lifecycle & Serialization ---
void *tree_sitter_vesti_external_scanner_create(void) {
    Scanner *s = (Scanner *)calloc(1, sizeof(Scanner));
    return s;
}

void tree_sitter_vesti_external_scanner_destroy(void *payload) {
    free(payload);
}

unsigned tree_sitter_vesti_external_scanner_serialize(void *payload, char *buffer) {
    Scanner *s = (Scanner *)payload;
    // Format: [len, t, a, g, ...]
    if (s->tag_len > MAX_TAG_LENGTH) return 0;
    
    buffer[0] = s->tag_len;
    if (s->tag_len > 0) {
        memcpy(&buffer[1], s->tag, s->tag_len);
    }
    return s->tag_len + 1;
}

void tree_sitter_vesti_external_scanner_deserialize(void *payload, const char *buffer, unsigned length) {
    Scanner *s = (Scanner *)payload;
    if (length == 0) {
        s->tag_len = 0;
        return;
    }
    
    s->tag_len = (uint8_t)buffer[0];
    if (s->tag_len > MAX_TAG_LENGTH) s->tag_len = 0; // Safety reset
    
    if (s->tag_len > 0 && length >= s->tag_len + 1) {
        memcpy(s->tag, &buffer[1], s->tag_len);
        s->tag[s->tag_len] = '\0';
    }
}

// --- Scanning Logic ---
bool tree_sitter_vesti_external_scanner_scan(void *payload, TSLexer *lx, const bool *valid) {
    Scanner *s = (Scanner *)payload;

    // 1. Handle LUACODE_END
    // We expect the exact sequence: :<tag>:#
    if (valid[LUACODE_END] && s->tag_len > 0) {
        // We do not skip whitespace here; syntax implies tight binding for the closer
        if (lx->lookahead == ':') {
            advance(lx);
            
            // Check against stored tag
            for (int i = 0; i < s->tag_len; i++) {
                if (lx->lookahead == s->tag[i]) {
                    advance(lx);
                } else {
                    return false; // Mismatch, backtrack (scanner returns false)
                }
            }

            // Check closing pattern :#
            if (lx->lookahead == ':') {
                advance(lx);
                if (lx->lookahead == '#') {
                    advance(lx);
                    lx->result_symbol = LUACODE_END;
                    s->tag_len = 0; // Reset state
                    return true;
                }
            }
        }
        return false;
    }

    // 2. Handle LUACODE_PAYLOAD
    if (valid[LUACODE_PAYLOAD]) {
        // The parser has consumed '#lu:'. We are now at the tag start.
        // Step A: Parse the opening tag
        
        // Skip optional whitespace before the tag starts (if any)
        while (isspace(lx->lookahead)) skip(lx);

        s->tag_len = 0;
        while (is_ascii_alnum(lx->lookahead)) {
            if (s->tag_len < MAX_TAG_LENGTH) {
                s->tag[s->tag_len++] = lx->lookahead;
            }
            advance(lx);
        }
        s->tag[s->tag_len] = '\0';

        // Tag must end with ':'
        if (lx->lookahead != ':') {
            return false;
        }
        advance(lx); // Consume the ':' separator

        // Step B: Consume content until we see :<tag>:#
        // We include the opening tag and colon in the payload token range.
        
        lx->result_symbol = LUACODE_PAYLOAD;
        
        for (;;) {
            // Mark the current position. If we match the delimiter, 
            // the token ends here (exclusive of delimiter).
            lx->mark_end(lx);

            if (lx->eof(lx)) {
                return true; // Return what we have
            }

            if (lx->lookahead == ':') {
                // Potential start of closing delimiter.
                // Speculatively check if the full delimiter matches.
                // We cannot "rewind" manually, but mark_end saves our "valid token" position.
                // If we match fully, we return true immediately (lexer resets to mark_end).
                // If we mismatch, we continue loop (lexer advanced, consuming the mismatch chars).

                bool match = true;
                advance(lx); // Consume ':'

                // Check tag
                for (int i = 0; i < s->tag_len; i++) {
                    if (lx->lookahead != s->tag[i]) {
                        match = false;
                        break; // Stop inner loop
                    }
                    advance(lx);
                }

                if (match) {
                    // Check closing :#
                    if (lx->lookahead == ':') {
                        advance(lx);
                        if (lx->lookahead == '#') {
                            // Full match found!
                            // We return true. The scanner "rewinds" to the last mark_end(),
                            // effectively leaving the delimiter for the NEXT token (LUACODE_END).
                            return true;
                        }
                    }
                }
                // If we are here, it was a partial match or mismatch.
                // We have advanced lx. The loop continues.
                // The characters we scanned are now part of the payload.
            } else {
                advance(lx);
            }
        }
    }

    return false;
}
