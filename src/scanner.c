/*
 * This file was generated by Gemini because there is no time to write this
 * manually, although I could
 */

#include <tree_sitter/parser.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

enum TokenType {
  LUACODE_START,
  LUACODE_CONTENT,
  LUACODE_END,
};

#define MAX_TAG_LENGTH 32

typedef struct {
  char tag[MAX_TAG_LENGTH + 1];
  uint8_t tag_len;
} Scanner;

// --- Lifecycle ---

void *tree_sitter_vesti_external_scanner_create(void) {
  return calloc(1, sizeof(Scanner));
}

void tree_sitter_vesti_external_scanner_destroy(void *payload) {
  free(payload);
}

unsigned tree_sitter_vesti_external_scanner_serialize(void *payload, char *buffer) {
  Scanner *s = (Scanner *)payload;
  if (s->tag_len > MAX_TAG_LENGTH) return 0;
  buffer[0] = s->tag_len;
  if (s->tag_len > 0) memcpy(&buffer[1], s->tag, s->tag_len);
  return s->tag_len + 1;
}

void tree_sitter_vesti_external_scanner_deserialize(void *payload, const char *buffer, unsigned length) {
  Scanner *s = (Scanner *)payload;
  if (length == 0) { s->tag_len = 0; return; }
  s->tag_len = (uint8_t)buffer[0];
  if (s->tag_len > MAX_TAG_LENGTH) s->tag_len = 0;
  if (s->tag_len > 0 && length >= s->tag_len + 1) {
    memcpy(s->tag, &buffer[1], s->tag_len);
    s->tag[s->tag_len] = '\0';
  }
}

// --- Helpers ---

static inline void advance(TSLexer *lx) { lx->advance(lx, false); }
static inline void skip(TSLexer *lx)    { lx->advance(lx, true); }

// Updated to include ':' as a valid tag character
static inline bool is_tag_char(int32_t c) {
  return (c >= '0' && c <= '9') ||
         (c >= 'A' && c <= 'Z') ||
         (c >= 'a' && c <= 'z') ||
         (c == ':');
}

// --- Scanner Logic ---

bool tree_sitter_vesti_external_scanner_scan(void *payload, TSLexer *lx, const bool *valid) {
  Scanner *s = (Scanner *)payload;

  // 1. LUACODE_START: #lu:<tag>:
  if (valid[LUACODE_START]) {
    while (isspace(lx->lookahead)) skip(lx);

    // Match prefix "#lu:"
    if (lx->lookahead != '#') return false; advance(lx);
    if (lx->lookahead != 'l') return false; advance(lx);
    if (lx->lookahead != 'u') return false; advance(lx);
    if (lx->lookahead != ':') return false; advance(lx);

    s->tag_len = 0;

    // Greedy tag matching loop
    while (true) {
      if (lx->eof(lx)) return false;

      int32_t current = lx->lookahead;

      if (!is_tag_char(current)) {
        // We hit a char that definitely isn't part of a tag (e.g. space).
        // This is an error because we expected a ':' separator previously.
        // Unless the previous char was the separator? No, we handle that below.
        return false;
      }

      // If current is ':', it MIGHT be the separator.
      // We must check the next character to decide.
      if (current == ':') {
        // We consume this colon tentatively.
        advance(lx); 
        
        // Check what comes next
        if (!is_tag_char(lx->lookahead)) {
          // Next char is NOT a tag char (e.g. space, newline).
          // Therefore, the colon we just consumed IS the separator.
          // We are done!
          if (s->tag_len == 0) return false; // Empty tag not allowed (#lu::)
          
          s->tag[s->tag_len] = '\0';
          lx->mark_end(lx);
          lx->result_symbol = LUACODE_START;
          return true;
        } 
        
        // Else: Next char IS a tag char. 
        // So the colon we just consumed was actually part of the tag.
        if (s->tag_len < MAX_TAG_LENGTH) s->tag[s->tag_len++] = ':';
        // Continue loop to process the 'next' char (which is now current lookahead)
      } else {
        // Regular alphanumeric char
        if (s->tag_len < MAX_TAG_LENGTH) s->tag[s->tag_len++] = (char)current;
        advance(lx);
      }
    }
  }

  // 2. LUACODE_END: :<tag>:#
  if (valid[LUACODE_END] && s->tag_len > 0) {
    // Note: No skip() here; delimiters usually bind tightly or grammar handles spaces before.
    // If we are at EOF, fail.
    
    if (lx->lookahead == ':') {
      advance(lx);
      
      // Match Tag
      for (int i = 0; i < s->tag_len; i++) {
        if (lx->lookahead != s->tag[i]) return false;
        advance(lx);
      }

      // Match Suffix ":#"
      if (lx->lookahead == ':') {
        advance(lx);
        if (lx->lookahead == '#') {
          advance(lx);
          lx->mark_end(lx);
          lx->result_symbol = LUACODE_END;
          s->tag_len = 0; // Reset
          return true;
        }
      }
    }
    return false;
  }

  // 3. LUACODE_CONTENT
  if (valid[LUACODE_CONTENT] && s->tag_len > 0) {
    lx->result_symbol = LUACODE_CONTENT;
    bool has_content = false;

    while (!lx->eof(lx)) {
      lx->mark_end(lx); // Valid content up to here

      if (lx->lookahead == ':') {
        // Potential delimiter start.
        // We need to verify if this is EXACTLY :<tag>:# without consuming it if it matches.
        // Since we can't rewind easily, we verify. If match -> return true (lexer resets to mark_end).
        // If mismatch -> consume the ':' and continue.

        // We do a manual lookahead loop
        int32_t c = lx->lookahead; // ':'
        advance(lx);

        // Check tag
        bool match = true;
        for (int i = 0; i < s->tag_len; i++) {
          if (lx->lookahead != s->tag[i]) { match = false; break; }
          advance(lx);
        }

        if (match) {
          if (lx->lookahead == ':') {
            advance(lx);
            if (lx->lookahead == '#') {
              // Found the delimiter!
              // Return true. Lexer rewinds to `mark_end` (before the first ':').
              return true;
            }
          }
        }
        
        // If we get here, it wasn't the delimiter.
        // The characters we advanced over are valid content.
        has_content = true;
      } else {
        advance(lx);
        has_content = true;
      }
    }
    return has_content;
  }

  return false;
}
